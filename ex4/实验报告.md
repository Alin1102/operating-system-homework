# 操作系统原理实验报告
## 个人信息
### 院系:数据科学与计算机学院
### 专业:计算机科学与技术(超算方向)
### 年级:2016级
### 姓名:谢江钊
### 学号:16337259
## 实验题目
### 中断机制编程技术
## 实验目的
1. 掌握pc微机的实模式硬件中断系统原理和中断服务程序设计方法，实现对时钟、键盘/鼠标等硬件中断的简单服务处理程序编程和调试，让你的原型操作系统在运行以前己有的用户程序时，能对异步事件正确捕捉和响应。
2. 掌握操作系统的系统调用原理，实现原型操作系统中的系统调用框架，提供若干简单功能的系统调用。
3. 学习握掌c语言库的设计方法，为自己的原型操作系统配套一个c程序开发环境，实现用自建的c语言开发简单的输入/输出的用户程序，展示封装的系统调用。

## 实验要求
1. 操作系统工作期间，利用时钟中断，在屏幕最边缘处动态画框，第一次用字母A，第二次画用字母B，如此类推，还可加上变色闪耀等效果。适当控制显示速度，以方便观察效果。
2. 编写键盘中断响应程序，原有的你设计的用户程序运行时，键盘事件会做出有事反应：当键盘有按键时，屏幕适当位置显示”OUCH! OUCH!”。
3. 在内核中，对34号、35号、36号和37号中断编写中断服务程序，分别在屏幕1/4区域内显示一些个性化信息。再编写一个汇编语言的程序，作为用户程序，利用int 34、int 35、int 36和int 37产生中断调用你这4个服务程序。
4. 扩充系统调用，实现三项以上新的功能，并编写一个测试所有系统调用功能的用户程序。


## 实验方案
### -Og优化与系统扩容
#### 系统部分
实验做到这里,原本分配的二十个扇区显然是不够了,因此决定将系统占用的扇区提升到54个扇区,同时对一些模块的编译过程加入了`-Og`优化,以减少不必要的空间浪费.
**Tips:注意到BIOS读软盘每次读取不能超过18个扇区.**
使用`0柱面,0磁头;0柱头,1磁头;1柱面,0磁头`范围内的所有扇区(共54个)作为系统占用的扇区.
#### 文件存储表部分
紧接着系统,放在第55个扇区(**注意文件存储表写入软盘的时候跟读是一样的,注意柱面和磁头的分配**)
#### 用户程序部分
放在第56个扇区及其以后

### OS重构
相比上一次的代码,将大量的函数按照功能分类写到了新的文件中,然后再给它们编写对应的头文件.在同一个文件中不断增加函数将会使得代码可读性下降;分离以后,当某个模块需要用到其他一些函数时,只需要`include`相关的头文件即可,在链接过程中会自动寻找相应的函数实现,而无需引入大量没有被引用到的函数.我将在接下来的部分解释不同模块的用途.
### 8259A中断控制器
与CPU的联系:
>中断的来源除了来自于硬件自身的NMI中断和来自于软件的INT n指令造成的软件中断之外，还有来自于外部硬件设备的中断，这些中断是可屏蔽的。这些中断也都通过PIC(Programmable Interrupt Controller)进行控制，并传递给CPU。在IBM PC机器兼容机上所使用的PIC是Intel 8259A芯片。8259A芯片的功能非常强大，但在IBM PC上，只用到比较简单的功能。 

简单而言,是联系中断和CPU的一个部件,让CPU能够恰当地得知发生了什么中断并且有顺序地去执行中断.
结合博客[8259A中断控制器详细介绍](https://blog.csdn.net/ustc_dylan/article/details/4106436)与PPT的大致结构图非常直观:
![1](https://lh3.googleusercontent.com/-MI8KrPPX3EU/Wsb83DRzPfI/AAAAAAAAGkw/h85GThCDHz4cW5xGGw9vANnCOPlaKOinwCHMYCw/s0/8259A%25E4%25B8%258ECPU.png)

#### 8259A的I/O端口

- 每个可编程中断控制器8259A都有两个I/O端口
- 主8259A所对应的端口地址为20h和21h
- 从8259A所对应的端口地址为A0h和A1h

| Chip - Purpose       | I/O port |
|----------------------|----------|
| Master PIC - Command | 0x0020   |
| Master PIC - Data    | 0x0021   |
| Slave PIC - Command  | 0x00A0   |
| Slave PIC - Data     | 0x00A1   |

偶数的端口是指定命令,奇数的端口是是传输数据
参考资料:[8259 PIC](https://wiki.osdev.org/8259_PIC)

#### EOI的具体实现
BIOS在加载时会初始化好8259A以准备接收中断,具体涉及到操作8259A内部的寄存器会比较复杂,不同的端口会有不同的分工:
![2](https://lh3.googleusercontent.com/-qZ5pLUVwAug/Wsb_Pcx06TI/AAAAAAAAGk8/RgXiOWoIadwkwjitONwFy59PHpG2xKqdQCHMYCw/s0/chrome_2018-04-06_13-01-48.png)

这个对于主从8259A只存在端口的不同,操作范围是一致的.

通过IN/OUT指令可以实现相关操作,比较常用的是:
```
    mov al,20h			; AL = EOI
    out 20h,al			; 发送EOI到主8529A
    out 0A0h,al
    iret
```

IBM提供的[技术文档](https://pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf)详细地解释了8259A的用法.
其中有一段:
>There are two forms of EOI command: Specific and
Non-Specific. When the 8259A is operated in modes
which perserve the fully nested structure, it can determine
which IS bit to reset on EOI. When a NonSpecific
EOI command is issued the 8259A will automatically
reset the highest IS bit of those that are
set, since in the fully nested mode the highest IS
level was necessarily the last level acknowledged
and serviced. A non-specific EOI can be issued with
OCW2 (EOI e 1, SL e 0, R e 0).

![3](https://lh3.googleusercontent.com/-pMTlyzlWGZE/WscAkkBTeTI/AAAAAAAAGlI/9jAVx9JKrUANIdmuc0eHRuusV22MHiTfgCHMYCw/s0/chrome_2018-04-06_13-07-28.png)

当我们需要使用其中`NON-SOECIFIC EOICOMMAND`时,设置好对应的位刚好就是20H,这也就是发送20H的来由.

#### 送20H到端口和STI,CLI的区别
首先,EOI送过去是为了告知8259A这个中断已经结束了,否则,8259A就以为这个中断没有结束就不会传优先级相对比较低的中断过来给CPU处理.
然后我们再看一下STI和CLI的定义:
CLI:
>Clears the interrupt flag if the current privilege level is at least as privileged as IOPL; affects no other flags. External interrupts disabled at the end of the cli instruction or from that point on until the interrupt flag is set.

SLI:
>Sets the interrupt flag to 1.

这两个指令是设置CPU标志寄存器的,让CPU能否响应送过来的中断.
所以这两个东西是不一样的,功能不同.

#### INT指令和IRET指令干了什么
在之前的实验中只是单纯的直接调用BIOS中断,这次跳进去中断以后需要去理解它们的功能:
INT:
>In Real Address Mode, the int imm8 pushes the flags, CS, and the return IP onto the stack, in that order, then jumps to the long pointer indexed by the interrupt number.

IRET:
>In Real Address Mode, iret pops CS, the flags register, and the instruction pointer from the stack and resumes the routine that was interrupted. In Protected Mode, the setting of the nested task flag (NT) determines the action of iret. The IOPL flag register bits are changed when CPL equals 0 and the new flag image is popped from the stack.

可以发现,两个指令相互配套,利用栈进行了跳转,压栈有三个东西,依次按照标志位,CS,IP进行压栈,出栈同理

#### 硬中断与软中断
>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上.
**硬中断经过8259A,执行完后需要发送EOI.**
>软中断仅与内核相联系
**软中断不需要发送EOI.**

#### BIOS中断服务程序在哪里
因为在执行完我们自己的中断任务后,还需要去执行BIOS原本的中断服务程序,那么这里就会需要一个跳转的功能.
回到我们最开始看到的内存分配表:
![](https://lh3.googleusercontent.com/-c_Jnqcc45_8/WtBdGFxpeWI/AAAAAAAAG7A/5OQZ2Z2t5d04517lXRX3hn6Dq-arrhh-ACHMYCw/s0/chrome_2018-04-13_15-32-37.png)
BIOS中断处理程序区显然已经超出了我们的OS所在的段,那么我们的近跳转`call 指令`就不可以再继续使用了!
因此在这里需要引入一个`call far`指令来解决问题.
#### 段间间接转移
使用`call far`指令进行,将读取四个字节,前两个字节作为`CS`,后两个字节作为`IP`.
### 核心问题
实现以上功能需要解决的几个关键问题:
- 如何修改中断向量表
- 如何编写中断服务程序

### 环境支持
- Nasm/GCC环境(Windows平台下用Mingw完美实现C的编译和链接)
- qemu虚拟机
- bochs模拟器(C编译后其实汇编内容非常多,不是太实用了)
- objdump(反汇编利器,支持对二进制文件和目标文件)

### 文件说明

boot:

| 文件             | 描述                                    |
| -------------- | ---------------------------------------- |
| boot.asm       | 引导程序,加载到0x7c00                     |

os:

| 文件             | 描述                                       |
| -------------- | ---------------------------------------- |
|os.c|系统入口C文件,系统从这里开始执行|
| interrupt.asm    | 自定义中断服务程序(汇编实现)              |
| interrupt.c       | 自定义中断服务程序(C实现)                      |
|stdio.h|标准输入输出函数声明|
|stdio.c|标准输入输出函数实现|
| stdlib_val.h         | stdlib.c中需要用到的全局变量              |
| stdlib.c       | 系统功能函数实现 |
| stdlib.h           | 系统功能函数声明     |
|string.c|字符串函数实现|
|string.h|字符串函数声明|
|system.asm|系统底层调用函数实现|
|system.h|系统底层调用函数声明|     

脚本:
| 脚本         | 功能                           |
| ---------- | ---------------------------- |
| make.bat   | 生成所有二进制文件(不带参数直接运行)          |
| merge.bat  | 整合所有二进制文件(不带参数直接运行)          |
| seeasm.bat | 对二进制文件进行反汇编(带参数(+二进制文件)直接运行) |
| play.bat   | 用bochs对merge.img进行调试         |

生成文件:

| 文件        | 描述               |
| --------- | ---------------- |
| os_c.o    | os.c生成的目标文件      |
| interrupt.o  | interrupt.c生成的目标文件  |
| stdlib.o  | stdlib.c生成的目标文件    |
| string.o  | string.c生成的目标文件    |
| stdio.o  | stdio.c生成的目标文件    |
| os.img | 链接以上五个文件生成的二进制文件 |
|merge,img|整合引导,OS,用户程序生成的二进制文件|

## 实验过程

### 中断服务向量的保存与修改
为了更好地提高代码复用率,减少以后添加需要修改的中断向量带来的工作量,在实现这一步都使用了模板式的函数.
#### 中断服务向量的保存
保存中断向量需要4个字节,两个字节(高)用来保存CS,两个字节(低)用来保存IP:
![](https://lh3.googleusercontent.com/-mqMYJEPE2XE/WtBtiptWnBI/AAAAAAAAG7Q/9GdDmO0e31Qks8YW-kqxNuoU18S4cZRsQCHMYCw/s0/POWERPNT_2018-04-13_16-42-49.png)
实现保存需要:
- 一个int类型的变量(4个字节),接受返回的中断服务程序地址
- 一个中断保存函数`int Save_Interrupt(int num);`(由汇编实现)
    - 函数传入中断号,返回中断号对应的中断服务程序地址(CS:IP)
    - 函数由汇编实现(实现在interrupt.asm)
实现详细:
```
_Save_Interrupt:
    mov ax,0
    mov es,ax
    mov al,4
    mov dl,[esp+04h]
    mul dl          ;计算得出中断号对应的中断向量表地址
    mov di,ax
    mov eax,[es:di]
    ret
```
GCC会将eax作为返回值,刚好是4个字节

#### 中断服务向量的修改
实现修改需要:
- 一个中断修改函数`void SetInterrupt(int num,void* program);`(由汇编实现)
    - 函数传入中断号和要修改到的地址
    - 函数由汇编实现(实现在interrupt.asm)

实现详细:
```
_SetInterrupt:
    sti         ;关中断,修改期间不要触发别的中断会避免奇奇怪怪的问题
    mov ax,0    ;因为自定义的服务程序没有超出最低的段,所以直接置0了
    mov es,ax
    mov al,4
    mov dl,[esp+04h]
    mul dl      ;计算得出需要修改的位置
    mov di,ax
    mov eax,[esp+08h]   ;一步到位直接将CS:IP赋给eax
    mov [es:di],eax
    cli                 ;开中断
    ret
```
利用eax这一步赋值挺方便的,连CS,IP的相对位置都不用考虑了.
### 中断变量服务程序程序需要怎么写
本次实验中涉及到两类中断
- 硬中断:时钟中断与键盘中断
- 软中断:中断号为34-37H和20H

时钟中断和键盘中断由硬件产生,软中断则是代码触发.因此,在处理硬中断的时候,要注意**发送EOI以及保护现场,恢复现场**.不然像时钟中断这种每间隔一段时间触发的中断,若是修改了寄存器,很可能就会导致正在运行的用户程序或者内核崩溃.

#### 保护现场要做什么
- 保护通用寄存器(可以用pusha实现,保存所有通用寄存器)
- 保护段寄存器(需要手动push相关寄存器)
- 保护当前指令地址(这一点int和iret会配套实现)
- 注意好对堆栈的维护

#### 中断服务程序C实现和汇编调用的方法
实现中断服务程序需要C和汇编部分相互配合.因为采用了GCC+Nasm的组合实现,所以在跳转的时候需要特别注意**维护堆栈**.
在此前的实验中,C调用汇编,汇编中会需要用`pop ecx;jmp cx`的方法进行,原因是因为GCC为32位堆栈,call 过去的时候会压入16位CS和16位IP,总共32位地址,因此返回的时候同样要弹出这些数据.
举例:
![](https://lh3.googleusercontent.com/-hWR_DQmMj3M/WtCZjdSaBaI/AAAAAAAAG7k/pO1d04SUThQLsj7njAqfn1YxmHWWub-pQCHMYCw/s0/Code_2018-04-13_19-50-33.png)
同理,当汇编call过来的时候,同样要考虑到C会弹出32位的CS:IP,因此在跳转过去时,需要提前压栈CS,避免破坏堆栈.而因为我并没有需要用到更高的段,因此可以选择直接压0.

#### 代码实现
在此之前需要说明一下,为了正常执行原先的中断功能,我将会采用`pushf+call far`的方法进行跳转,这样的效果等同于指令`int`的压栈,包含了FLAG,CS,IP,因此当原来的中断服务程序执行到`iret`的时候能够正常返回.

举08H为例:
```
_Int08h:
    push ds
    push es             ;段寄存器压栈,保护好现场
    pushf               ;标志寄存器压栈
    pusha               ;通用寄存器压栈
    pushf               ;和call far组合替代int中断指令
    call far [_interrupt_8]     ;_interrupt_8的值是原来的中断服务程序地址,跳转先执行相关功能
    call _Show_Time             ;这是汇编代码的标号,所以直接call过去.如果是GCC的标号,需要提前push 0
    jmp _Int_hard_ret           ;准备返回(分开提高代码复用率)
_Int_hard_ret:
    mov al,20h                  
    out 20h,al
    out 0A0h,al                 ;告诉主从8259A关于EOI的信息
    popa
    popf
    pop es
    pop ds                      ;弹出现场数据,恢复现场
    iret                        ;对应触发中断的int,返回原先执行的指令接着执行
```

对于软中断则可以比较轻松:
```

```
### 实验结果

引导界面:


## 实验创新点

### 滚屏的实现
滚屏可以由BIOS中断实现,但是需要根据显示内容的多少进行提前滚屏,**不能够在打印超出屏幕的内容后再滚屏.**
一开始,我在C里面往屏幕中打印信息都是直接调用汇编中的函数去使用中断.后来打算实现这样的功能时,选择将汇编中的函数用C包装起来,就能够很方便地实现更安全的打印:
```
void  print(char* str,int row,int col,int len,int style){
  while(row + len/80  >  23){ //如果要打印的信息超出了屏幕范围
    ClearScreen(0,0,24,79,1); //向上滚动一行
    Terminalrow--; //光标向上滚动
    row--;
  }
  WriteStr(str,row,col,len,style); //滚动完成,输出数据
}
```
WriteStr是汇编中的函数,调用BIOS中断.当某个命令要打印内容时只使用print,就可以实现滚屏.

### 关机和重启
参考了网络上的资料,都是BIOS功能的调用,`INT 19H`将CS:IP指向了0x7c00而已,这种方式用作热重启并不是十分适合,内存区域并没有进行清空

### uname指令
打印个人信息

### 清屏功能
调用BIOS清屏,并对相关变量重新进行初始化.

### 选择用户程序进行执行
模仿Linux下的`./`命令,对字符串进行了解析,然后利用用户存储表查找.为了实现这个功能,实现了
strcpy(字符串复制),strcmp(字符串比较),len(取得字符串长度),IntconvStr(数字转字符串),StrConvInt(字符串转数字)一系列功能.为以后拓展更多指令做下了非常坚实的基础.

### 脚本整合操作

写了几个小脚本方便了生产环境


## 实验总结
1. GCC+NASM的环境配置真的是非常不容易了,做了好几天,心情比较复杂,但是最后代码还是跑起来了.也还是会遗留一些32位的代码没有办法去解决.但是GCC+NASM用起来还是语法熟悉会更方便一点.
2. 文件储存表的设计也是考虑了很久.如果要考虑以树(例如B+树)的形式去建立的话,要手写malloc去申请内存空间,然后将指针连接起来,最后写回磁盘.中间还有很多想的不是很清楚的细枝末节,所以暂时就没有去做这个.但是还是有好几个解决方案:
- 建立一个数组,然后用下标代替指针,也就是以数组的形式实现树.整理好数组的内容后把数组写入磁盘就可以了,读取起来也方便,偏移不难计算.
- 每个扇区放一个用户程序的信息,然后固定根节点的扇区,记录子节点的扇区,这样找到根节点就可以层层向下找,并且磁盘写入操作本来就是以扇区为单位,也就可以很方便地把数据写入/读取.但是这样会浪费大量地磁盘空间,所以也不是一个很好的实现方法.

   最后还是选择数组地形式来记录,包装在结构体里面,但是没有去做用数组建立树,这个任务也许下次实验会加以实现,或者采用散列表的形式.无论如何,这一点还有很多值得改进的地方.

3. 如何存储用户程序信息
  做了不少尝试,因为用户程序信息有两个用途,包括在界面上展示给用户和实现内部的程序加载.举个例子,如果我要显示程序所在的扇区,那么就应该以字符串的形式记录,这样BIOS中断就能够直接取字符串的地址进行转换.如果是我要加载用户程序,那么这个扇区就应该以数值的形式保存,这样BIOS中断才能够直接拿扇区的数值过去加载.
  记录成字符串其实转换为数字会更加方便,但是字符串做成定长的时候,有时候有需要把前面的0选择删除,这样显示出来的信息才符合用户需要.从信息存储的角度来看的话,还是应该记录成数值的,不仅提升空间利用率,也符合程序设计的习惯.
  选择了以数值的形式存储,就需要考虑怎么转换成字符串了.因为BIOS中断输出字符串需要的是字符串地址,那么字符串在OS运行过程中应该作为一个全局变量而不是局部变量,所以我定义了一个字符数组(长度为4),并且在转换函数中根据转换后的字符串长度返回了字符数组+偏移,这样代码不仅整洁并且与中断调用无缝对接:
```
char*  IntconvStr(int num){
  int i=3;			//从字符串末尾开始转换
  while(num>0){
    sectorstr[i]=num%10+'0';
    i--;
    num/=10;
  }
  return  &sectorstr[i+1];	//返回转换后的第一个数字的地址
}
```
4. 字符串结尾
  用C写字符串时,会自动在字符串结尾处加上'\0',这里要说明以下,**'\0'实则上是8bit的0**;但是在用汇编写字符串类数据,比如`db "Hello"`这样的代码时,编译器是不会帮你自动补上结尾的0的,很多时候为了计算字符串的长度我又需要这个0,正确的做法应该是db 0,而不应该写成`db "Hello\n"`,这样做的话编译器会将斜杠和0分开转换成ASCII码,从而无法得到正确的结果.

5. 一开始并不是很明白链接器的作用,也不是很理解include的作用,会经常出现符号重定义的问题,后来去查阅相关资料后,再利用`objdump -t xxx.o`指令查看符号表后解决了很多这样的问题.链接器很重要的一部分工作就是解析对应的符号.
  另外,编译的时候,include的文件会被展开到c文件中,所以要注意不要在两份文件中include**带有全局变量**的头文件,这样会导致符号重定义的问题.

6. 作为一个操作系统,我在模块上的安排还有很多不够成熟的地方,只是将详细的模块实现从os.c中分离出去,实际上很多模块还可以进一步分散到不同文件中.不仅仅是便于修改,更多时候,当我们需要执行某一个命令时,可以选择等到那个时候再把它加载到内存中,从而节约内存的使用.

7. 光标位置的移动也是一个问题,从用户角度来看,光标应该在字符串的最后位置.为了实现回显,设定了两个变量Terminalrow和Terminalcol,来确定最后一个字符的位置.
```
if(inputchar==8&&Terminalcol>0){ //如果是退格则需要删除该字符
  print(nullchar,Terminalrow,Terminalcol,1,15);//删除字符方法是在该位置打印一个ASCII为0的字符
  Terminalcol--;
  userinput[Terminalcol]=0;		//注意字符串要更新
}
else  if (inputchar!=8){ //如果是正常输入的字符则放入用户字符串中
  userinput[Terminalcol]=inputchar;
  Terminalcol++;
}
if(Terminalcol>=1)
  print(&userinput[Terminalcol-1],Terminalrow,Terminalcol,1,15); //打印用户输入的字符串
else
  print(TerminalSign,Terminalrow,0,1,10);
```
最初我采用了另外一种解决方案,每次打印该次用户输入的字符串,然后对字符串随后的空间清屏.用户字符串和随后的空白区域还是用光标来界定.这种做法其实不好,因为以后可能加入移动光标到字符串中间修改内容的功能时,光标往后的区域会被清空而不是保留.所以这种逐个修改字符的做法会更好.	

8. 在进行软盘的读写时,一定要注意扇区,磁头和柱面的顺序关系,这个是由软盘的结构决定的:

![2011102411454881](C:\Users\xieji\OneDrive\操作系统实验\16337259_谢江钊_实验三\截图\2011102411454881.png)

由于我在磁盘中使用超过了18个扇区,所以需要使用到1磁头的区域,在此区域设置中断的扇区数需要减去18,否则读写会出现问题.

## 参考文献

- IA-32 Assembly Language Reference Manual
  https://docs.oracle.com/cd/E19455-01/806-3773/index.html
- 8259A中断控制器详细介绍
  https://blog.csdn.net/ustc_dylan/article/details/4106436
- 
