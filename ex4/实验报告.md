# 操作系统原理实验报告
## 个人信息
### 院系:数据科学与计算机学院
### 专业:计算机科学与技术(超算方向)
### 年级:2016级
### 姓名:谢江钊
### 学号:16337259
## 实验题目
### 中断机制编程技术
## 实验目的
1. 掌握pc微机的实模式硬件中断系统原理和中断服务程序设计方法，实现对时钟、键盘/鼠标等硬件中断的简单服务处理程序编程和调试，让你的原型操作系统在运行以前己有的用户程序时，能对异步事件正确捕捉和响应。
2. 掌握操作系统的系统调用原理，实现原型操作系统中的系统调用框架，提供若干简单功能的系统调用。
3. 学习握掌c语言库的设计方法，为自己的原型操作系统配套一个c程序开发环境，实现用自建的c语言开发简单的输入/输出的用户程序，展示封装的系统调用。

## 实验要求
1. 操作系统工作期间，利用时钟中断，在屏幕最边缘处动态画框，第一次用字母A，第二次画用字母B，如此类推，还可加上变色闪耀等效果。适当控制显示速度，以方便观察效果。
2. 编写键盘中断响应程序，原有的你设计的用户程序运行时，键盘事件会做出有事反应：当键盘有按键时，屏幕适当位置显示”OUCH! OUCH!”。
3. 在内核中，对34号、35号、36号和37号中断编写中断服务程序，分别在屏幕1/4区域内显示一些个性化信息。再编写一个汇编语言的程序，作为用户程序，利用int 34、int 35、int 36和int 37产生中断调用你这4个服务程序。
4. 扩充系统调用，实现三项以上新的功能，并编写一个测试所有系统调用功能的用户程序。


## 实验方案
### -Og优化与系统扩容
#### 系统部分
实验做到这里,原本分配的二十个扇区显然是不够了,因此决定将系统占用的扇区提升到54个扇区,同时对一些模块的编译过程加入了`-Og`优化,以减少不必要的空间浪费.
**Tips:注意到BIOS读软盘每次读取不能超过18个扇区.**
使用`0柱面,0磁头;0柱头,1磁头;1柱面,0磁头`范围内的所有扇区(共54个)作为系统占用的扇区.
#### 文件存储表部分
紧接着系统,放在第55个扇区(**注意文件存储表写入软盘的时候跟读是一样的,注意柱面和磁头的分配**)
#### 用户程序部分
放在第56个扇区及其以后

### OS重构
相比上一次的代码,将大量的函数按照功能分类写到了新的文件中,然后再给它们编写对应的头文件.在同一个文件中不断增加函数将会使得代码可读性下降;分离以后,当某个模块需要用到其他一些函数时,只需要`include`相关的头文件即可,在链接过程中会自动寻找相应的函数实现,而无需引入大量没有被引用到的函数.我将在接下来的部分解释不同模块的用途.
### 8259A中断控制器
与CPU的联系:
>中断的来源除了来自于硬件自身的NMI中断和来自于软件的INT n指令造成的软件中断之外，还有来自于外部硬件设备的中断，这些中断是可屏蔽的。这些中断也都通过PIC(Programmable Interrupt Controller)进行控制，并传递给CPU。在IBM PC机器兼容机上所使用的PIC是Intel 8259A芯片。8259A芯片的功能非常强大，但在IBM PC上，只用到比较简单的功能。 

简单而言,是联系中断和CPU的一个部件,让CPU能够恰当地得知发生了什么中断并且有顺序地去执行中断.
结合博客[8259A中断控制器详细介绍](https://blog.csdn.net/ustc_dylan/article/details/4106436)与PPT的大致结构图非常直观:
![1](https://lh3.googleusercontent.com/-MI8KrPPX3EU/Wsb83DRzPfI/AAAAAAAAGkw/h85GThCDHz4cW5xGGw9vANnCOPlaKOinwCHMYCw/s0/8259A%25E4%25B8%258ECPU.png)

#### 8259A的I/O端口

- 每个可编程中断控制器8259A都有两个I/O端口
- 主8259A所对应的端口地址为20h和21h
- 从8259A所对应的端口地址为A0h和A1h

| Chip - Purpose       | I/O port |
|----------------------|----------|
| Master PIC - Command | 0x0020   |
| Master PIC - Data    | 0x0021   |
| Slave PIC - Command  | 0x00A0   |
| Slave PIC - Data     | 0x00A1   |

偶数的端口是指定命令,奇数的端口是是传输数据
参考资料:[8259 PIC](https://wiki.osdev.org/8259_PIC)

#### EOI的具体实现
BIOS在加载时会初始化好8259A以准备接收中断,具体涉及到操作8259A内部的寄存器会比较复杂,不同的端口会有不同的分工:
![2](https://lh3.googleusercontent.com/-qZ5pLUVwAug/Wsb_Pcx06TI/AAAAAAAAGk8/RgXiOWoIadwkwjitONwFy59PHpG2xKqdQCHMYCw/s0/chrome_2018-04-06_13-01-48.png)

这个对于主从8259A只存在端口的不同,操作范围是一致的.

通过IN/OUT指令可以实现相关操作,比较常用的是:
```
    mov al,20h			; AL = EOI
    out 20h,al			; 发送EOI到主8529A
    out 0A0h,al
    iret
```

IBM提供的[技术文档](https://pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf)详细地解释了8259A的用法.
其中有一段:
>There are two forms of EOI command: Specific and
Non-Specific. When the 8259A is operated in modes
which perserve the fully nested structure, it can determine
which IS bit to reset on EOI. When a NonSpecific
EOI command is issued the 8259A will automatically
reset the highest IS bit of those that are
set, since in the fully nested mode the highest IS
level was necessarily the last level acknowledged
and serviced. A non-specific EOI can be issued with
OCW2 (EOI e 1, SL e 0, R e 0).

![3](https://lh3.googleusercontent.com/-pMTlyzlWGZE/WscAkkBTeTI/AAAAAAAAGlI/9jAVx9JKrUANIdmuc0eHRuusV22MHiTfgCHMYCw/s0/chrome_2018-04-06_13-07-28.png)

当我们需要使用其中`NON-SOECIFIC EOICOMMAND`时,设置好对应的位刚好就是20H,这也就是发送20H的来由.

#### 送20H到端口和STI,CLI的区别
首先,EOI送过去是为了告知8259A这个中断已经结束了,否则,8259A就以为这个中断没有结束就不会传优先级相对比较低的中断过来给CPU处理.
然后我们再看一下STI和CLI的定义:
CLI:
>Clears the interrupt flag if the current privilege level is at least as privileged as IOPL; affects no other flags. External interrupts disabled at the end of the cli instruction or from that point on until the interrupt flag is set.
SLI:
>Sets the interrupt flag to 1.

这两个指令是设置CPU标志寄存器的,让CPU能否响应送过来的中断.
所以这两个东西是不一样的,功能不同.

#### INT指令和IRET指令干了什么
在之前的实验中只是单纯的直接调用BIOS中断,这次跳进去中断以后需要去理解它们的功能:
INT:
>In Real Address Mode, the int imm8 pushes the flags, CS, and the return IP onto the stack, in that order, then jumps to the long pointer indexed by the interrupt number.

IRET:
>In Real Address Mode, iret pops CS, the flags register, and the instruction pointer from the stack and resumes the routine that was interrupted. In Protected Mode, the setting of the nested task flag (NT) determines the action of iret. The IOPL flag register bits are changed when CPL equals 0 and the new flag image is popped from the stack.

可以发现,两个指令相互配套,利用栈进行了跳转,压栈有三个东西,依次按照标志位,CS,IP进行压栈,出栈同理

#### BIOS中断服务程序在哪里
因为在执行完我们自己的中断任务后,还需要去执行BIOS原本的中断服务程序,那么这里就会需要一个跳转的功能.
回到我们最开始看到的内存分配表:
![](https://lh3.googleusercontent.com/-c_Jnqcc45_8/WtBdGFxpeWI/AAAAAAAAG7A/5OQZ2Z2t5d04517lXRX3hn6Dq-arrhh-ACHMYCw/s0/chrome_2018-04-13_15-32-37.png)
BIOS中断处理程序区显然已经超出了我们的OS所在的段,那么我们的近跳转`call 指令`就不可以再继续使用了!
因此在这里需要引入一个`call far`指令来解决问题.
#### 段间间接转移
使用`call far`指令进行,将读取四个字节,前两个字节作为`CS`,后两个字节作为`IP`.
### 核心问题
实现以上功能需要解决的几个关键问题:
- 如何修改中断向量表
- 如何编写中断服务程序

### 环境支持
- Nasm/GCC环境(Windows平台下用Mingw完美实现C的编译和链接)
- qemu虚拟机
- bochs模拟器(C编译后其实汇编内容非常多,不是太实用了)
- objdump(反汇编利器,支持对二进制文件和目标文件)

### 文件说明

boot:

| 文件             | 描述                                    |
| -------------- | ---------------------------------------- |
| boot.asm       | 引导程序,加载到0x7c00                     |

os:

| 文件             | 描述                                       |
| -------------- | ---------------------------------------- |
|os.c|系统入口C文件,系统从这里开始执行|
| interrupt.asm    | 自定义中断服务程序(汇编实现)              |
| interrupt.c       | 自定义中断服务程序(C实现)                      |
|stdio.h|标准输入输出函数声明|
|stdio.c|标准输入输出函数实现|
| stdlib_val.h         | stdlib.c中需要用到的全局变量              |
| stdlib.c       | 系统功能函数实现 |
| stdlib.h           | 系统功能函数声明     |
|string.c|字符串函数实现|
|string.h|字符串函数声明|
|system.asm|系统底层调用函数实现|
|system.h|系统底层调用函数声明|     

脚本:
| 脚本         | 功能                           |
| ---------- | ---------------------------- |
| make.bat   | 生成所有二进制文件(不带参数直接运行)          |
| merge.bat  | 整合所有二进制文件(不带参数直接运行)          |
| seeasm.bat | 对二进制文件进行反汇编(带参数(+二进制文件)直接运行) |
| play.bat   | 用bochs对merge.img进行调试         |

生成文件:

| 文件        | 描述               |
| --------- | ---------------- |
| os_c.o    | os.c生成的目标文件      |
| interrupt.o  | interrupt.c生成的目标文件  |
| stdlib.o  | stdlib.c生成的目标文件    |
| string.o  | string.c生成的目标文件    |
| stdio.o  | stdio.c生成的目标文件    |
| os.img | 链接以上五个文件生成的二进制文件 |
|merge,img|整合引导,OS,用户程序生成的二进制文件|

## 实验过程

### 操作系统如何跟用户程序进行交互
引导程序启动完毕以后,操作系统就被加载入内存中,位于0x7e00,这个位置刚好紧接着引导程序,CPU的控制权被交到操作系统,随后,操作系统将从软盘的特定位置加载用户程序存储安排表进入内存.这时,操作系统进入了终端状态,当用户执行相关用户程序时,操作系统就会从用户存储安排表中取得用户程序在磁盘中的位置,将用户程序加载入内存,操作系统将当前的CS:IP压栈,然后跳转到用户程序,这个时候用户程序开始取得CPU控制权.用户触发特定的事件(例如输入ESC)就会使得用户程序按照原先的程序设计,将操作系统压栈的CS:IP出栈,跳转回到操作系统继续执行.
BIOS加载后,将OS搬进内存:
```
...
loados:
mov  ax,cs ;段地址 ; 存放数据的内存基地址
mov  es,ax ;设置段地址（不能直接mov es,段地址）
mov  ah,2  ;功能号
mov  al,20 ;扇区数
mov  dl,0  ;驱动器号 ; 软盘为0，硬盘和U盘为80H
mov  dh,0  ;磁头号 ; 起始编号为0
mov  ch,0  ;柱面号 ; 起始编号为0
int  13H
...
jmp OS 	   ;OS equ 0x7e00
```
OS运行后,打印必要的提示信息,进入循环:
```
void  Terminal(){
  buildtable(); //用来临时创建文件存储表的函数
  void* p=(void*)0xa600; //操作系统结束,从这里开始放文件存储表
  Load(p,1,4,1); //加载文件存储表
while(1){
  Terminalcol=0;
  print(TerminalSign,Terminalrow,0,1,10); //打印终端符号
  for(int i =  0;i<80;i++){
    userinput[i]=0; //清空用户上一次的输入
    }
  Wait_Task(); //等待用户输入一条指令
  Task(userinput); //执行指令
  }
}
```
OS 不断监听用户在终端输入随后执行指令,通过CALL和RET指令进行与用户程序的交互(本质上都是地址的压栈出栈).
我将在接下来介绍更详细的实现.
### C和汇编的参数传递
在X86下,C通过压栈的方式传递参数,对于参数列表,**从右到左依次压栈**.而在汇编中,我们可以通过堆栈来获取这些参数.
我在os_lib.h中声明了一个清屏的函数,它是这样的
`void  ClearScreen(int x_top,int y_top,int x_down,int y_down,int isScroll)`,随后我在os.c调用了它,用objdump对二进制文件进行反汇编,参数为
`objdump -D -Mintel,i8086 -b binary -m Filename`,得到结果取部分如下:

```
      34:       67 66 c7 44 24 10 00    mov    DWORD PTR [esp+0x10],0x0
      3b:       00 00 00
      3e:       67 66 c7 44 24 0c 4f    mov    DWORD PTR [esp+0xc],0x4f
      45:       00 00 00
      48:       67 66 c7 44 24 08 18    mov    DWORD PTR [esp+0x8],0x18
      4f:       00 00 00
      52:       67 66 c7 44 24 04 00    mov    DWORD PTR [esp+0x4],0x0
      59:       00 00 00
      5c:       67 66 c7 04 24 00 00    mov    DWORD PTR [esp],0x0
      63:       00 00
      65:       66 e8 96 0d 00 00       call   0xe01
```
与理解相符合,而在汇编中,我们只需要到堆栈取得相应的值就可以了:
```
   mov  bl, byte [ebp+18h]
   mov  cx, word [ebp+14h]
   mov  dl, byte [ebp+10h]
   mov  dh, byte [ebp+0ch]
   mov  bp, word [ebp+08h]  
```
关于X86的堆栈调用结构还可以用更直观的图来表示:

![271644419475745](C:\Users\xieji\OneDrive\操作系统实验\16337259_谢江钊_实验三\截图\271644419475745.jpg)
这个是GCC的调用约定,调用函数执行几个步骤:
- 参数从右向左依次压栈
- 调用call指令,压入当前的CS:IP,也就是要返回的地址
- 进入被调用函数后将ebp压栈,同时将esp赋值给ebp,然后从这里开始进行函数操作.

而我们要取得的第一个参数,就放在ebp+8h的地方,当我们在汇编中需要用到时在这个位置取就可以了.值得注意的是,C文件里面函数的调用会自动做`push ebp;mov ebp,esp;`的操作,但是C调用汇编函数的时候,这一些就要我们自己写了.也可以不遵循约定靠自己去维护堆栈,注意要计算好第一个参数的位置.
汇编函数执行结束以后,将堆栈中的返回地址pop出来,就可以返回C部分继续执行代码了

另外,如果汇编要返回值给C函数的话,需要将需要返回的值放在eax寄存器,C会将寄存器的值赋给相应的变量

### C和汇编目标文件怎么链接,代码怎么从C开始执行
链接器需要将几个文件合并起来生成一个输出文件,而链接时目标程序的顺序同样需要考虑,查阅资料得知目标文件最简单的合并方式就是**按序叠加**.所以,在进行目标文件链接的时候,我们需要将os.c生成的目标文件作为第一个目标文件,并且要在os.c文件的开头加入`__asm__("jmpl $0, $__main\n");`跳转到main函数执行.否则,如果让os.asm生成的目标文件作为第一个目标文件,就要在os.asm中引用main函数跳转执行,不然链接器就会先执行os.asm中的文件.
这个问题,也就是一个入口点的问题,在这种环境下需要手动去设置.如果是ELF文件,头部会定义好入口.链接的命令参数如下:
`ld -m i386pe -N os_c.o os_lib.o os_asm.o -o os.tmp -T linker.txt`
这里要提一下link script,因为生成目标文件时无法再用`org 0100h`这样的指令,所以只能放到链接中.
Link Script里面有LMA和VMA的概念,这里引用官方文档的说法:
>The first is the _VMA_, or virtual memory address. This is the address the section will have when the output file is run. The second is the _LMA_, or load memory address. This is the address at which the section will be loaded. In most cases the two addresses will be the same. An example of when they might be different is when a data section is loaded into ROM, and then copied into RAM when the program starts up (this technique is often used to initialize global variables in a ROM based system). In this case the ROM address would be the LMA, and the RAM address would be the VMA.

而我们设计操作系统的时候,只需要在Link Script里面指定LMA就可以了.

### 未解决符号表/导出符号表/地址重定向表
链接过程比较复杂,我了解了比较重要的一部分,这三个概念的理解解决了大部分链接期间的疑惑:
- unresolved symbol table
- exprot symbol table
- address redirect table
  以C为例,变量和函数的定义可以放在别的文件中.那么链接成目标文件的时候,就需要把这个没有在本文件实现的函数或者变量记在unresolved symbol table中.如果其他文件定义了这个函数或者变量并且属于全局变量或函数的话,那么就会把它放在exprot symbol table.等到链接器链接的时候就可以让它们找到对应的符号标志,然后去替换二进制文件中不确定的函数地址.
  另外,链接器将它们合并起来时,有先后顺序也就意味着地址要重新进行安排,这也就是地址重定向表的作用,让它们能够最终确定自己的位置.

### 用户存储表的建立
用户存储表是一个结构体的实例,结构体的声明为:
```
struct  Proginfo{
  char name[8][16]; //用户程序名
  int size[8];	  //程序大小
  int sector[8];	  //程序所在扇区
  int count;		  //程序数量
};
```
用二维数组的形式记录程序信息,最多能够记录8个程序.在磁盘上构建这个表时,只需要定义一个指向它的指针,然后调用BIOS中断将这段数据写入到对应扇区.
```
struct Proginfo progtable; //实例化结构体
...
Write(&progtable,1,4,1); //往磁盘写入文件存储表
```
当在函数中实例化结构体作为局部变量时,结构体被放置在堆栈部分,而实例化作为全局变量时,数据会被放在紧接着代码的数据部分.写入磁盘时,会把结构体的二进制数据写入相应的扇区.

当OS运行时,结构体数据所在扇区也会被加载到内存的特定位置,我们只需要定义一个结构体指针指向这部分内存地址就可以读取相应的数据了.
```
struct Proginfo* Table=(struct Proginfo*)Table_addr;//初始化指针指向这部分内存
```
### 无效输入处理与程序返回
之前的实验没有注意到一个问题,对于键盘输入`INT 10H`,如果是扫描键盘缓冲区,在扫描到字符后是不会清空键盘缓冲区的,如果不进行处理,下一个字符输入就不会被扫描到(键盘缓冲区是一个环形队列) .另外,如果是等待读入一个字符,那么这个字符会从缓冲区中移除.相关的中断说明也有提及到这一点:

>Function 01H -- Check keyboard buffer Input: AH=01H Returns: ZF= 1 if the keyboard buffer is empty ZF= 0 if there is at least one character available. In this case, the ASCII and scan codes are placed in the AL and AH registers as in function 00\. The codes, however, are not removed from the buffer.

注意到扫描到缓冲区有内容后修改了ZF标志,那么可以利用JE或者JNE指令(通过ZF标志判断跳转不跳转)决定是否要清空缓冲区.我查阅相关资料没有找到清空缓冲区的中断,那么就直接通过等待读入字符的方法实现清空.
```
mov  ah,1		
int  0x16		;扫描缓冲区
jne $+5			;如果有字符输入则执行跳转
jmp shoot		;没有字符则继续执行用户程序
mov  ah,0		
int  0x16		;从缓冲区读入字符,该字符从缓冲区中清除
cmp  al,27		;比较是否是ESC
jne $+3			;如果不是ESC则该字符无效,继续循环
ret				;如果是ESC则返回操作系统
jmp shoot
```

### 实验结果

引导界面:


## 实验创新点

### 滚屏的实现
滚屏可以由BIOS中断实现,但是需要根据显示内容的多少进行提前滚屏,**不能够在打印超出屏幕的内容后再滚屏.**
一开始,我在C里面往屏幕中打印信息都是直接调用汇编中的函数去使用中断.后来打算实现这样的功能时,选择将汇编中的函数用C包装起来,就能够很方便地实现更安全的打印:
```
void  print(char* str,int row,int col,int len,int style){
  while(row + len/80  >  23){ //如果要打印的信息超出了屏幕范围
    ClearScreen(0,0,24,79,1); //向上滚动一行
    Terminalrow--; //光标向上滚动
    row--;
  }
  WriteStr(str,row,col,len,style); //滚动完成,输出数据
}
```
WriteStr是汇编中的函数,调用BIOS中断.当某个命令要打印内容时只使用print,就可以实现滚屏.

### 关机和重启
参考了网络上的资料,都是BIOS功能的调用,`INT 19H`将CS:IP指向了0x7c00而已,这种方式用作热重启并不是十分适合,内存区域并没有进行清空

### uname指令
打印个人信息

### 清屏功能
调用BIOS清屏,并对相关变量重新进行初始化.

### 选择用户程序进行执行
模仿Linux下的`./`命令,对字符串进行了解析,然后利用用户存储表查找.为了实现这个功能,实现了
strcpy(字符串复制),strcmp(字符串比较),len(取得字符串长度),IntconvStr(数字转字符串),StrConvInt(字符串转数字)一系列功能.为以后拓展更多指令做下了非常坚实的基础.

### 脚本整合操作

写了几个小脚本方便了生产环境


## 实验总结
1. GCC+NASM的环境配置真的是非常不容易了,做了好几天,心情比较复杂,但是最后代码还是跑起来了.也还是会遗留一些32位的代码没有办法去解决.但是GCC+NASM用起来还是语法熟悉会更方便一点.
2. 文件储存表的设计也是考虑了很久.如果要考虑以树(例如B+树)的形式去建立的话,要手写malloc去申请内存空间,然后将指针连接起来,最后写回磁盘.中间还有很多想的不是很清楚的细枝末节,所以暂时就没有去做这个.但是还是有好几个解决方案:
- 建立一个数组,然后用下标代替指针,也就是以数组的形式实现树.整理好数组的内容后把数组写入磁盘就可以了,读取起来也方便,偏移不难计算.
- 每个扇区放一个用户程序的信息,然后固定根节点的扇区,记录子节点的扇区,这样找到根节点就可以层层向下找,并且磁盘写入操作本来就是以扇区为单位,也就可以很方便地把数据写入/读取.但是这样会浪费大量地磁盘空间,所以也不是一个很好的实现方法.

   最后还是选择数组地形式来记录,包装在结构体里面,但是没有去做用数组建立树,这个任务也许下次实验会加以实现,或者采用散列表的形式.无论如何,这一点还有很多值得改进的地方.

3. 如何存储用户程序信息
  做了不少尝试,因为用户程序信息有两个用途,包括在界面上展示给用户和实现内部的程序加载.举个例子,如果我要显示程序所在的扇区,那么就应该以字符串的形式记录,这样BIOS中断就能够直接取字符串的地址进行转换.如果是我要加载用户程序,那么这个扇区就应该以数值的形式保存,这样BIOS中断才能够直接拿扇区的数值过去加载.
  记录成字符串其实转换为数字会更加方便,但是字符串做成定长的时候,有时候有需要把前面的0选择删除,这样显示出来的信息才符合用户需要.从信息存储的角度来看的话,还是应该记录成数值的,不仅提升空间利用率,也符合程序设计的习惯.
  选择了以数值的形式存储,就需要考虑怎么转换成字符串了.因为BIOS中断输出字符串需要的是字符串地址,那么字符串在OS运行过程中应该作为一个全局变量而不是局部变量,所以我定义了一个字符数组(长度为4),并且在转换函数中根据转换后的字符串长度返回了字符数组+偏移,这样代码不仅整洁并且与中断调用无缝对接:
```
char*  IntconvStr(int num){
  int i=3;			//从字符串末尾开始转换
  while(num>0){
    sectorstr[i]=num%10+'0';
    i--;
    num/=10;
  }
  return  &sectorstr[i+1];	//返回转换后的第一个数字的地址
}
```
4. 字符串结尾
  用C写字符串时,会自动在字符串结尾处加上'\0',这里要说明以下,**'\0'实则上是8bit的0**;但是在用汇编写字符串类数据,比如`db "Hello"`这样的代码时,编译器是不会帮你自动补上结尾的0的,很多时候为了计算字符串的长度我又需要这个0,正确的做法应该是db 0,而不应该写成`db "Hello\n"`,这样做的话编译器会将斜杠和0分开转换成ASCII码,从而无法得到正确的结果.

5. 一开始并不是很明白链接器的作用,也不是很理解include的作用,会经常出现符号重定义的问题,后来去查阅相关资料后,再利用`objdump -t xxx.o`指令查看符号表后解决了很多这样的问题.链接器很重要的一部分工作就是解析对应的符号.
  另外,编译的时候,include的文件会被展开到c文件中,所以要注意不要在两份文件中include**带有全局变量**的头文件,这样会导致符号重定义的问题.

6. 作为一个操作系统,我在模块上的安排还有很多不够成熟的地方,只是将详细的模块实现从os.c中分离出去,实际上很多模块还可以进一步分散到不同文件中.不仅仅是便于修改,更多时候,当我们需要执行某一个命令时,可以选择等到那个时候再把它加载到内存中,从而节约内存的使用.

7. 光标位置的移动也是一个问题,从用户角度来看,光标应该在字符串的最后位置.为了实现回显,设定了两个变量Terminalrow和Terminalcol,来确定最后一个字符的位置.
```
if(inputchar==8&&Terminalcol>0){ //如果是退格则需要删除该字符
  print(nullchar,Terminalrow,Terminalcol,1,15);//删除字符方法是在该位置打印一个ASCII为0的字符
  Terminalcol--;
  userinput[Terminalcol]=0;		//注意字符串要更新
}
else  if (inputchar!=8){ //如果是正常输入的字符则放入用户字符串中
  userinput[Terminalcol]=inputchar;
  Terminalcol++;
}
if(Terminalcol>=1)
  print(&userinput[Terminalcol-1],Terminalrow,Terminalcol,1,15); //打印用户输入的字符串
else
  print(TerminalSign,Terminalrow,0,1,10);
```
最初我采用了另外一种解决方案,每次打印该次用户输入的字符串,然后对字符串随后的空间清屏.用户字符串和随后的空白区域还是用光标来界定.这种做法其实不好,因为以后可能加入移动光标到字符串中间修改内容的功能时,光标往后的区域会被清空而不是保留.所以这种逐个修改字符的做法会更好.	

8. 在进行软盘的读写时,一定要注意扇区,磁头和柱面的顺序关系,这个是由软盘的结构决定的:

![2011102411454881](C:\Users\xieji\OneDrive\操作系统实验\16337259_谢江钊_实验三\截图\2011102411454881.png)

由于我在磁盘中使用超过了18个扇区,所以需要使用到1磁头的区域,在此区域设置中断的扇区数需要减去18,否则读写会出现问题.

## 参考文献

- IA-32 Assembly Language Reference Manual
  https://docs.oracle.com/cd/E19455-01/806-3773/index.html
- 8259A中断控制器详细介绍
  https://blog.csdn.net/ustc_dylan/article/details/4106436
- 
