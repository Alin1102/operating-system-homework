## 概述
进程切换非常麻烦,等下再更
## 日志记录
- [x] 跨段用户程序函数修改(注意段寄存器对齐/Org理解)
- [x] 指针也不能直接用值传递啊
- [x] 注意下一个段的段偏移是0x1000而不是0x0001
- [x] retf与call far搭配使用
- [x] 注意段切换时的段寄存器修改 
- [x] 能跑两个进程了(未用时钟中断)
- [x] 能跑两个进程了(用时钟中断)
- [x] 注意标志寄存器在进程初始化时的设置
- [x] 只能在Bochs下面跑
- [x] 多进程系统调用 
- [x] 进程名执行

## 尚未解决的问题
    - Task函数过大似乎会使得代码崩掉,原因未明
    - QEMU运行下似乎也会爆炸,原因未明

## 用户程序与操作系统所在段的分离
    这次的工作量相对比较大,在此之前,运行用户程序是先把用户程序`Load`进内存,通过`call`方法进行调用运行的.当用户程序的加载地址和操作系统分离后,我们需要注意好几个问题,在这里,不对用户程序加载入内存的过程讨论(操作不变):
    - 0x7E00-0x9FFFF 属于我们可以自由读写的内存区域
    - 实模式下内存地址怎么计算?
        - 段寄存器x16+偏移地址.对于0x10000的物理地址,对应的地址表达应该为`0x1000:0x0000`.`x16`意味着仅仅是左移一位,`0x0000:0x0010`和`0x0001:0x0000`所对应的物理地址是一致的.实际操作时很容易误以为段寄存器从0改变成1就变成新的一个段了.
    - 如何进行段间的切换 `call far`切换
    - 段寄存器和堆栈的设置
        - 这些工作应该由内核去预先初始化好,而应该与用户程序分离,用户程序只需要设置好偏移量就好了(偏移量选择遵循常规的0X100h).至于堆栈,也应该设置在用户程序所在段的0xffff偏移上开始.
    - 具体的初始化和切换
        - 分两步进行,进程的初始化和利用进程切换实现跳转(重复利用代码),下面讨论下技术细节
## 进程切换的方法


重点关注文件:
- `Sched`
- `Interrupt`