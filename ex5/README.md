## 概述
进程切换非常麻烦,等下再更
## 日志记录
- [x] 跨段用户程序函数修改(注意段寄存器对齐/Org理解)
- [x] 指针也不能直接用值传递啊
- [x] 注意下一个段的段偏移是0x1000而不是0x0001
- [x] retf与call far搭配使用
- [x] 注意段切换时的段寄存器修改 
- [x] 能跑两个进程了(未用时钟中断)
- [x] 能跑两个进程了(用时钟中断)
- [x] 注意标志寄存器在进程初始化时的设置
- [x] 只能在Bochs下面跑
- [x] 多进程系统调用 
- [x] 进程名执行

## 尚未解决的问题
    - Task函数过大似乎会使得代码崩掉,原因未明
    - QEMU运行下似乎也会爆炸,原因未明

## 用户程序与操作系统所在段的分离
这次的工作量相对比较大,在此之前,运行用户程序是先把用户程序`Load`进内存,通过`call`方法进行调用运行的.当用户程序的加载地址和操作系统分离后,我们需要注意好几个问题,在这里,不对用户程序加载入内存的过程讨论(操作不变):
- 0x7E00-0x9FFFF 属于我们可以自由读写的内存区域
- 实模式下内存地址怎么计算?
    - 段寄存器x16+偏移地址.对于0x10000的物理地址,对应的地址表达应该为`0x1000:0x0000`.`x16`意味着仅仅是左移一位,`0x0000:0x0010`和`0x0001:0x0000`所对应的物理地址是一致的.实际操作时很容易误以为段寄存器从0改变成1就变成新的一个段了.
- 如何进行段间的切换 `call far`切换
- 段寄存器和堆栈的设置
    - 这些工作应该由内核去预先初始化好,而应该与用户程序分离,用户程序只需要设置好偏移量就好了(偏移量选择遵循常规的0X100h).至于堆栈,也应该设置在用户程序所在段的0xffff偏移上开始.
- 具体的初始化和切换
    - 分两步进行,进程的初始化和利用进程切换实现跳转(重复利用代码),下面讨论下技术细节
## 进程切换的方法
利用时间中断,每次时钟中断过来的时候都进行进程的切换.为了方便调试,另外设置了38H中断方便进行手动测试.具体实现在`interrupt.asm`中,进行了中断的设置.
在本次实验中,并没有把内核也看作是进程.所以,一旦进入进程,就没有办法返回继续执行内核了,这部分的缺陷会在下一次实验中补上.
既然如此,中断就应该有两种模式,一是在内核中执行无需进行进程切换,二是在用户进程中执行需要进行进程切换.
而判断当前是否处于用户进程,办法有很多,包括判断进程数量等等,但是利用变量进行判断需要每次修改ds来读入变量,因此我在实验中采用了更简单的判断方案:看一下栈的段地址是不是0(即是否是内核栈).

每次中断发生时,先将所有上下文数据压入用户栈,然后复制一份到PCB中;随后取PCB中下一个进程的上下文数据,复制到进程栈中,然后切换到进程栈,取出相应数据,开始执行下一个进程,具体代码参考`os/interrupt.asm`
## 上一个实验的BUG
上一次实验在Bochs中没有办法运行,根本原因是在中断跳转(执行原本中断功能)时取中断服务程序时没有修改ds导致了程序崩溃.

## 汇编问题rep movsb 和 cld 是什么意思? 
引用下百度的回答:
>先说说MOVSB（MOVe String Byte）：即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。
而REP（REPeat）指令就是“重复”的意思，术语叫做“重复前缀指令”，因为既然是传递字符串，则不可能一个字（节）一个字（节）地传送，所以需要有一个寄存器来控制串长度。这个寄存器就是CX，指令每次执行前都会判断CX的值是否为0（为0结束重复，不为0，CX的值减1），以此来设定重复执行的次数。因此设置好CX的值之后就可以用REP MOVSB了。
CLD（CLear Direction flag）则是清方向标志位，也就是使DF的值为0，在执行串操作时，使地址按递增的方式变化，这样便于调整相关段的的当前指针。这条指令与STD（SeT Direction flag）的执行结果相反，即置DF的值为1。

 重点关注文件:
- `Sched`
- `Interrupt`